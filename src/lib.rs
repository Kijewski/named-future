// Copyright (c) 2023 René Kijewski <crates.io@k6i.de>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// --- LLVM Exceptions to the Apache 2.0 License ----
//
// As an exception, if, as a result of your compiling your source code, portions
// of this Software are embedded into an Object form of such source code, you
// may redistribute such embedded portions in such Object form without complying
// with the conditions of Sections 4(a), 4(b) and 4(d) of the License.
//
// In addition, if you combine or link compiled forms of this Software with
// software that is licensed under the GPLv2 ("Combined Software") and if a
// court of competent jurisdiction determines that the patent provision (Section
// 3), the indemnity provision (Section 9) or other Section of the License
// conflicts with the conditions of the GPLv2, you may retroactively and
// prospectively choose to deem waived or otherwise exclude such Section(s) of
// the License, but only in their entirety and only with respect to the Combined
// Software.

//! # named-future: *Give your Future a name!*
//!
//! Wrap a [`Future`](core::future::Future) in a sized struct, so it can be use in traits,
//! or as return type, without the need for [`Box<…>`](std::boxed::Box), [`dyn …`], or [`impl …`].
//!
//! ```rust
//! # use named_future::named_future;
//! /// A slow multiplication
//! ///
//! /// # Struct
//! ///
//! /// Future generated by [`slow_mul`]
//! #[named_future]
//! pub async fn slow_mul(factor1: u32, factor2: u32) -> u32 {
//! #   /*
//!     sleep(Duration::from_secs(5)).await;
//! #   */
//!     factor1 * factor2
//! }
//! ```
//!
//! Expands to
//!
//! ```rust
//! # use core::{future::Future, pin::Pin, task::{Context, Poll}};
//! /// A slow multiplication
//! pub fn slow_mul(factor1: u32, factor2: u32) -> SlowMul {
//! #   /*
//!     ...
//! #   */
//! #   todo!()
//! }
//!
//! /// Future generated by [`slow_mul`]
//! pub struct SlowMul {
//! #   /*
//!     ...
//! #   */
//! }
//!
//! impl Future for SlowMul {
//!     type Output = u32;
//!
//!     #[inline]
//!     fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
//! #       /*
//!         ...
//! #       */
//! #       todo!()
//!     }
//! }
//! ```
//!
//! Additionally it will implement a `Drop`, so a dropped future will work fine,
//! and `Debug` for your convenience.
//!
//! The proc_macro `#[named_future]` has the following optional arguments:
//!
//! - **`#[named_future(Send)]`**:  
//!   - Implement [`Send`] for the generated `struct`.
//!     It is currently not possible to detect automatically if the `struct` should be `Send`,
//!     so you have to ask for the implementation manually.
//!     Even so, it is ensured that the [`Future`](core::future::Future) is send,
//!     and the compilation will fail otherwise.
//!
//! - **`#[named_future(Sync)]`**:  
//!   - Implement [`Sync`] for the generated `struct`. Please see the explanation for `Send`.
//!
//! - **`#[named_future(Type = Name)]`**:  
//!   - Instead of the default name, i.e. using pascal case of the function name,
//!     you can override the name using this argument.
//!     You can also override the visibility of the `struct` using this argument: `Type = pub Name`.
//!     By default, the visibility of the function is copied.
//!
//! - **`#[named_future(Crate = some::path)]`**:  
//!   - If you have renamed the dependency in your `Cargo.toml`,
//!     e.g. `renamed = { package = "named-future", version = "0.0.1" }`,
//!     then you have to specify its name / path.
//!     Defaults to `::named_future`.
//!
//! To add a documentation to your function, and the generated struct,
//! you can separate both sections with a line `/// # Struct`
//!
//! The library code can be used with `#![no_std]`.
//!
//! Because of limitations in rust, it is currently not possible to implement a “named future” for
//! generic functions:
//! “error: generic `Self` types are currently not permitted in anonymous constants”.
//!
//! [`dyn …`]: https://doc.rust-lang.org/1.65.0/std/keyword.dyn.html
//! [`impl …`]: https://doc.rust-lang.org/1.65.0/std/keyword.impl.html
//!

#![cfg_attr(docsrs, feature(doc_cfg))]
#![cfg_attr(not(docsrs), no_std)]
#![allow(unknown_lints)]
#![warn(absolute_paths_not_starting_with_crate)]
#![warn(elided_lifetimes_in_paths)]
#![warn(explicit_outlives_requirements)]
#![warn(meta_variable_misuse)]
#![warn(missing_copy_implementations)]
#![warn(missing_debug_implementations)]
#![warn(missing_docs)]
#![warn(non_ascii_idents)]
#![warn(noop_method_call)]
#![warn(single_use_lifetimes)]
#![warn(unused_extern_crates)]
#![warn(unused_lifetimes)]

#[doc(hidden)]
pub mod machinery;

/// Please refer to the [crate level documentation](crate).
#[cfg(feature = "proc-macros")]
#[cfg_attr(docsrs, doc(cfg(feature = "proc-macros")))]
pub use named_future_proc_macros::named_future;
